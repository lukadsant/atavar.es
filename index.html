<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bento</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        /* Bento button styles (lightweight, no build required) */
        .bento-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            width: 100%;
            padding: 1rem 1.1rem;
            background: linear-gradient(180deg, #ffffff, #f3f4f6);
            border-radius: 0.75rem;
            box-shadow: 0 6px 18px rgba(15, 23, 42, 0.12), inset 0 -6px 12px rgba(0,0,0,0.03);
            border: 1px solid rgba(0,0,0,0.06);
            color: #0f172a; /* text color */
            text-decoration: none;
            overflow: hidden;
            transition: transform .12s ease, box-shadow .12s ease;
        }
        .bento-btn:hover { transform: translateY(-3px) scale(1.01); box-shadow: 0 14px 30px rgba(99,102,241,0.12); }
        .bento-left { display:flex; align-items:center; gap:0.75rem; }
        .bento-label { font-weight:600; color:#0f172a; }

        /* Decorative compartments on the right */
        .bento-compartments { display:flex; align-items:center; gap:0.5rem; }
        .bento-compartments .big {
            width:56px; height:40px; border-radius:8px;
            background: linear-gradient(180deg,#fff,#e9eef7);
            box-shadow: inset 0 -6px 10px rgba(0,0,0,0.05);
            border: 1px solid rgba(0,0,0,0.04);
        }
        .bento-compartments .col { display:flex; flex-direction:column; gap:6px; }
        .bento-compartments .small { width:22px; height:14px; border-radius:6px;
            background: linear-gradient(180deg,#fff,#f6f7fb);
            box-shadow: inset 0 -4px 8px rgba(0,0,0,0.04);
            border: 1px solid rgba(0,0,0,0.03);
        }

        /* Responsive: hide decorative compartments on very small screens */
        @media (max-width:520px) {
            .bento-compartments { display:none; }
        }

        /* Mini bento grid (simplified mechanics) */
        .grid-bento {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            /* aumentar a altura mínima das linhas para ocupar mais vertical */
            grid-auto-rows: minmax(80px, 1fr);
            gap: 0.5rem;
            width: 100%;
            height: 100%; /* preencher o pai quando o pai tiver altura definida */
            /* subtle grid overlay to show cell boundaries */
            background-image:
                linear-gradient(to right, rgba(255,255,255,0.06) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.06) 1px, transparent 1px);
            /* match the logical grid (5 columns x 4 rows) so lines align with cells */
            background-size: calc(100% / 5) calc(100% / 4), calc(100% / 5) calc(100% / 4);
            background-repeat: repeat;
        }
        .grid-item {
            border-radius: 0.75rem;
            overflow: hidden;
            display:flex;
            align-items:center;
            justify-content:center;
            font-weight:600;
            color:var(--text-color,#0f172a);
        }
    </style>
</head>
<body class="overflow-y-hidden w-full h-screen relative">
         <img src="https://plus.unsplash.com/premium_photo-1670333242712-6e95c863592b?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=1113'" alt="" srcset="" class="h-full w-full absolute bottom-0 left-0 object-cover z-0">

        <div class="w-full h-screen flex flex-col justify-end sm:mx-auto sm:max-w-[90rem] relative bottom-0 top-10 left-0 right-0 z-10 translate-x-l absolute">
           
            <!-- Imagem e título ficam FORA do card grande -->
            <div class="w-full flex flex-col items-center gap-4 mb-4">
                <div class="h-[12rem] w-[12rem]">
                    <img src="https://i.pinimg.com/1200x/07/e9/d4/07e9d4a1646a289bfc5185358213674c.jpg" alt="bento" srcset="" class="h-full w-full rounded-full object-cover shadow-2xl shadow-white/30 border-4 border-white hover:scale-110 transition-all duration-300 ease-in-out hover:shadow-indigo-600">
                </div>
                <div class="w-full flex flex-col items-center">
                    <h1 class="text-white text-3xl font-bold">BENTO</h1>
                    <h1 class="text-white text-xl text-zinc-400">@Lukadsant</h1>
                </div>
            </div>

            <!-- Card principal agora contém apenas o Mini Bento (grid) -->
            <div class="w-full h-[55rem] rounded-t-[3rem] bg-black/50 backdrop-blur-xl border border-zinc-400 shadow-2xl shadow-white/30">
                <div class="w-full h-full px-8 py-8 flex flex-col">
                    <div class="flex justify-between items-center mb-4">
                        <div class="flex items-center gap-4">
                            <h3 class="text-white font-semibold">Mini Bento (simplificado)</h3>
                            <span id="miniCount" class="text-sm text-gray-300">Itens: 0</span>
                            <span id="miniWarning" class="text-sm text-rose-400 hidden">Grid cheia — limpe para adicionar mais</span>
                        </div>
                        <div class="flex gap-2">
                            <button id="addItemBtn" class="bg-white text-zinc-800 px-3 py-1 rounded-md">Adicionar item</button>
                            <button id="compactBtn" class="bg-white text-zinc-800 px-3 py-1 rounded-md">Compactar</button>
                            <button id="clearBtn" class="bg-transparent border border-white text-white px-3 py-1 rounded-md">Limpar</button>
                        </div>
                    </div>

                    <div id="miniGrid" class="grid-bento"></div>
                </div>
            </div>

            <!-- link de rodapé abaixo do card -->
            <div class="w-full flex justify-center mt-6">
                <a href="http://berolab.app" target="_blank" rel="noopener noreferrer" class="text-white font-medium">Feito na berolab</a>
            </div>
        </div>

    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script>
            // MiniBento: pequeno refactor OO, mantendo comportamento e UX anteriores.
            (function(){
                /* --- Constants --- */
                const GRID_W = 5, GRID_H = 4;
                const COLORS = ['#60a5fa','#f472b6','#34d399','#facc15','#a78bfa','#ef4444','#06b6d4','#fb923c'];
                const LABELS = ['Site','Insta','Zap','YouTube','GitHub','Blog','Spotify','Contato','Portfólio'];
                const SHAPES_RAW = [
                    [[0,0]],
                    [[0,0],[1,0]],
                    [[0,0],[0,1]],
                    [[0,0],[1,0],[0,1],[1,1]]
                ];

                /* --- Shape --- */
                class Shape {
                    constructor(cells){
                        this.cells = cells.map(c => [c[0], c[1]]);
                        this.w = Math.max(...this.cells.map(c=>c[0])) + 1;
                        this.h = Math.max(...this.cells.map(c=>c[1])) + 1;
                    }
                }

                /* --- Item --- */
                class Item {
                    constructor(id, shape, color, label){
                        this.id = id; this.shape = shape; this.color = color; this.label = label;
                    }
                }

                /* --- Grid: pure logic, no DOM --- */
                class Grid {
                    constructor(w, h){ this.w = w; this.h = h; }

                    makeEmpty(){ return Array.from({length:this.h},()=>Array(this.w).fill(null)); }

                    canPlace(matrix, shape, x, y){
                        return shape.cells.every(([dx,dy])=>{
                            const nx = x+dx, ny = y+dy;
                            return nx>=0 && nx<this.w && ny>=0 && ny<this.h && matrix[ny][nx]===null;
                        });
                    }

                    place(matrix, shape, x, y, id){ shape.cells.forEach(([dx,dy])=> matrix[y+dy][x+dx] = id); }

                    countFree(matrix){
                        let n=0; for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) if(matrix[y][x]===null) n++; return n;
                    }

                    // try to layout items in the given order (positions tested in random order)
                    layoutWithOrder(order){
                        const mat = this.makeEmpty();
                        const placed = [];
                        for(const it of order){
                            // build positions list and shuffle
                            const positions = [];
                            for(let y=0;y<this.h;y++) for(let x=0;x<this.w;x++) positions.push([x,y]);
                            positions.sort(()=>Math.random() - 0.5);
                            for(const [x,y] of positions){
                                if(this.canPlace(mat, it.shape, x, y)){
                                    this.place(mat, it.shape, x, y, it.id);
                                    placed.push(Object.assign({}, it, { x, y }));
                                    break;
                                }
                            }
                        }
                        return { placed, free: this.countFree(mat) };
                    }

                    // randomized order wrapper
                    layoutAll(items){
                        const order = items.slice().sort(()=>Math.random()-0.5);
                        return this.layoutWithOrder(order);
                    }

                    // compact: try a few strategies and return the best result
                    compact(items){
                        if(items.length === 0) return { placed: [], free: this.w * this.h };
                        const attempts = [];
                        // largest-first
                        attempts.push(this.layoutWithOrder(items.slice().sort((a,b)=> b.shape.cells.length - a.shape.cells.length)));
                        // smallest-first
                        attempts.push(this.layoutWithOrder(items.slice().sort((a,b)=> a.shape.cells.length - b.shape.cells.length)));
                        // random attempts
                        for(let i=0;i<12;i++) attempts.push(this.layoutAll(items));

                        // choose best (most placed, then more free)
                        let best = attempts[0];
                        for(const a of attempts){
                            if(a.placed.length > best.placed.length) best = a;
                            else if(a.placed.length === best.placed.length && a.free > best.free) best = a;
                        }
                        return best;
                    }
                }

                /* --- MiniBentoApp: UI + orchestration --- */
                class MiniBentoApp {
                    constructor(opts){
                        this.grid = new Grid(opts.gridW, opts.gridH);
                        this.miniGridEl = opts.miniGridEl;
                        this.addBtn = opts.addBtn; this.compactBtn = opts.compactBtn; this.clearBtn = opts.clearBtn;
                        this.countEl = opts.countEl; this.warnEl = opts.warnEl;

                        this.shapes = SHAPES_RAW.map(c=>new Shape(c));
                        this.colors = COLORS.slice(); this.labels = LABELS.slice();

                        this.items = []; this.nextId = 1; this.lastPlacedCount = 0;

                        // wire UI
                        this.addBtn && this.addBtn.addEventListener('click', ()=> this.addItem());
                        this.compactBtn && this.compactBtn.addEventListener('click', ()=> this.compact());
                        this.clearBtn && this.clearBtn.addEventListener('click', ()=> this.clear());
                    }

                    randomFrom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

                    pickRandomItemData(){
                        return {
                            shape: this.randomFrom(this.shapes),
                            color: this.randomFrom(this.colors),
                            label: this.randomFrom(this.labels)
                        };
                    }

                    addItem(){
                        const { shape, color, label } = this.pickRandomItemData();
                        const item = new Item(this.nextId++, shape, color, label);
                        this.addWithFallback(item);
                    }

                    // try inserting item with original shape; if not, try fallbacks 2x1 -> 1x2 -> 1x1
                    // Prefer deterministic placement using current placed coordinates (no randomization) when possible.
                    addWithFallback(item){
                        // If there are existing placed items (they have x/y), try to find a free spot using current layout
                        const anyPlaced = this.items.some(it => typeof it.x === 'number' && typeof it.y === 'number');
                        if(anyPlaced){
                            // try place item directly without touching other items
                            const mat = this.grid.makeEmpty();
                            for(const it of this.items){ if(typeof it.x === 'number' && typeof it.y === 'number') this.grid.place(mat, it.shape, it.x, it.y, it.id); }

                            // scan row-major for a fit
                            let placed = false;
                            for(let y=0; y<this.grid.h && !placed; y++){
                                for(let x=0; x<this.grid.w && !placed; x++){
                                    if(this.grid.canPlace(mat, item.shape, x, y)){
                                        // commit
                                        item.x = x; item.y = y; this.items.push(item); placed = true; break;
                                    }
                                }
                            }
                            if(placed){
                                // placed successfully
                                const placedArr = this.items.filter(it=> typeof it.x === 'number' && typeof it.y === 'number').map(it=> Object.assign({}, it));
                                this.applyRender({ placed: placedArr, free: this.grid.countFree(mat)});
                                this.hideWarning(); this.enableAdd(); return;
                            }

                            // couldn't place with current fixed layout -> try fallbacks (also deterministic)
                            const findBy = (count, dx, dy)=> this.shapes.find(s=> s.cells.length === count && (dx===undefined || s.cells.some(c=> c[0]===dx && c[1]===dy)));
                            const oneByOne = findBy(1);
                            const twoH = findBy(2,1,0);
                            const twoV = findBy(2,0,1);
                            const fallbacks = [];
                            if(item.shape.cells.length === 4){ if(twoH) fallbacks.push(twoH); if(twoV) fallbacks.push(twoV); if(oneByOne) fallbacks.push(oneByOne); }
                            else if(item.shape.cells.length === 2){ if(oneByOne) fallbacks.push(oneByOne); }
                            else if(item.shape.cells.length === 1){ /* nothing */ }
                            else { if(oneByOne) fallbacks.push(oneByOne); }

                            for(const fb of fallbacks){
                                const matFb = this.grid.makeEmpty();
                                for(const it of this.items){ if(typeof it.x === 'number' && typeof it.y === 'number') this.grid.place(matFb, it.shape, it.x, it.y, it.id); }
                                let placedFb = false;
                                for(let y=0; y<this.grid.h && !placedFb; y++){
                                    for(let x=0; x<this.grid.w && !placedFb; x++){
                                        if(this.grid.canPlace(matFb, fb, x, y)){
                                            const candidate = new Item(this.nextId++, fb, item.color, item.label);
                                            candidate.x = x; candidate.y = y; this.items.push(candidate);
                                            placedFb = true; break;
                                        }
                                    }
                                }
                                if(placedFb){
                                    const placedArr = this.items.filter(it=> typeof it.x === 'number' && typeof it.y === 'number').map(it=> Object.assign({}, it));
                                    const free = this.grid.countFree(matFb);
                                    const desc = fb.cells.length === 1 ? '1x1' : (fb.cells[0][1] === 0 ? '2x1' : '1x2');
                                    this.showTemporaryWarning(`Não coube no formato — adicionado como ${desc}`);
                                    this.applyRender({ placed: placedArr, free });
                                    return;
                                }
                            }

                            // no placement possible with deterministic attempts -> signal full
                            this.showWarning('Grid cheia — limpe para adicionar mais'); this.disableAdd();
                            const placedArr = this.items.filter(it=> typeof it.x === 'number' && typeof it.y === 'number').map(it=> Object.assign({}, it));
                            // recalc free from mat
                            const free = this.grid.countFree(mat);
                            this.applyRender({ placed: placedArr, free });
                            return;
                        }

                        // fallback: no existing placed coordinates (first layout) -> behave as before and randomize layout
                        this.items.push(item);
                        let res = this.grid.layoutAll(this.items);
                        if(res.placed.length === this.items.length){ this.hideWarning(); this.enableAdd(); this.applyRender(res); return; }

                        // remove last and try the randomized fallbacks as before
                        this.items.pop(); this.nextId--;
                        const findByR = (count, dx, dy)=> this.shapes.find(s=> s.cells.length === count && (dx===undefined || s.cells.some(c=> c[0]===dx && c[1]===dy)));
                        const oneByOneR = findByR(1);
                        const twoHR = findByR(2,1,0);
                        const twoVR = findByR(2,0,1);
                        const fallbacksR = [];
                        if(item.shape.cells.length === 4){ if(twoHR) fallbacksR.push(twoHR); if(twoVR) fallbacksR.push(twoVR); if(oneByOneR) fallbacksR.push(oneByOneR); }
                        else if(item.shape.cells.length === 2){ if(oneByOneR) fallbacksR.push(oneByOneR); }
                        else if(item.shape.cells.length === 1){ /* nothing */ }
                        else { if(oneByOneR) fallbacksR.push(oneByOneR); }

                        for(const fb of fallbacksR){
                            const candidate = new Item(this.nextId++, fb, item.color, item.label);
                            this.items.push(candidate);
                            res = this.grid.layoutAll(this.items);
                            if(res.placed.length === this.items.length){
                                const desc = fb.cells.length === 1 ? '1x1' : (fb.cells[0][1] === 0 ? '2x1' : '1x2');
                                this.showTemporaryWarning(`Não coube no formato — adicionado como ${desc}`);
                                this.applyRender(res); return;
                            }
                            this.items.pop(); this.nextId--;
                        }

                        // couldn't place even after fallbacks
                        this.showWarning('Grid cheia — limpe para adicionar mais'); this.disableAdd(); this.applyRender(res);
                    }

                    applyRender(result){
                        // persist placed coordinates into items (so DnD and future ops know positions)
                        this.items.forEach(it => { delete it.x; delete it.y; });
                        for(const p of result.placed){
                            const it = this.items.find(i => i.id === p.id);
                            if(it) { it.x = p.x; it.y = p.y; }
                        }
                        this.render(result.placed);
                        this.updateStatus(result.placed.length, result.free);
                    }

                    render(placed){
                        // UI-only rendering; always consult canonical items for shape/color/label
                        this.miniGridEl.innerHTML = '';
                        this.lastPlacedCount = placed.length;
                        for(const placedItem of placed){
                            const canonical = this.items.find(i => i.id === placedItem.id) || placedItem;
                            const el = document.createElement('div');
                            const w = Math.max(...canonical.shape.cells.map(([dx])=>dx)) + 1;
                            const h = Math.max(...canonical.shape.cells.map(([_,dy])=>dy)) + 1;
                            el.className = 'grid-item';
                            el.style.background = canonical.color || placedItem.color;
                            el.style.gridColumn = `${placedItem.x+1} / span ${w}`;
                            el.style.gridRow = `${placedItem.y+1} / span ${h}`;
                            el.textContent = canonical.label || placedItem.label;
                            // dataset for drag identification and better touch behaviour
                            el.dataset.id = placedItem.id;
                            el.style.touchAction = 'none';
                            this.miniGridEl.appendChild(el);
                        }
                        // bind draggable behaviour after DOM is updated
                        this.bindDraggables();
                    }

                    bindDraggables(){
                        if(typeof interact === 'undefined') return; // lib missing
                        try{ interact('.grid-item').unset(); } catch(e){}

                        const cellW = this.miniGridEl.clientWidth / this.grid.w;
                        const cellH = this.miniGridEl.clientHeight / this.grid.h;

                        interact('.grid-item').draggable({
                            inertia: false,
                            modifiers: [
                                // snap movement to the grid cells for clearer UX
                                interact.modifiers.snap({
                                    targets: [ interact.snappers.grid({ x: cellW, y: cellH }) ],
                                    range: Infinity,
                                    relativePoints: [{ x: 0, y: 0 }]
                                }),
                                interact.modifiers.restrictRect({ restriction: this.miniGridEl })
                            ],
                            listeners: {
                                move: event => {
                                    const target = event.target;
                                    const dx = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
                                    const dy = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
                                    target.style.transform = `translate(${dx}px, ${dy}px)`;
                                    target.setAttribute('data-x', dx);
                                    target.setAttribute('data-y', dy);
                                },
                                end: event => {
                                    const target = event.target;
                                    const rect = this.miniGridEl.getBoundingClientRect();
                                    // use element center after snap to decide cell — more robust than raw client coords
                                    const tRect = target.getBoundingClientRect();
                                    const dropCenterX = (tRect.left - rect.left) + (tRect.width / 2);
                                    const dropCenterY = (tRect.top - rect.top) + (tRect.height / 2);
                                    let col = Math.floor(dropCenterX / cellW);
                                    let row = Math.floor(dropCenterY / cellH);
                                    col = Math.max(0, Math.min(this.grid.w-1, col));
                                    row = Math.max(0, Math.min(this.grid.h-1, row));
                                    const id = Number(target.dataset.id);
                                    // attempt to move the item
                                    this.tryMoveItemTo(id, col, row);
                                    // cleanup transform attrs
                                    target.style.transform = '';
                                    target.removeAttribute('data-x'); target.removeAttribute('data-y');
                                }
                            }
                        });
                    }

                    tryMoveItemTo(id, col, row){
                        const item = this.items.find(i=>i.id===id);
                        if(!item) return;
                        // build matrix with other already-placed items
                        const mat = this.grid.makeEmpty();
                        for(const it of this.items){
                            if(it.id === id) continue;
                            if(typeof it.x === 'number' && typeof it.y === 'number'){
                                this.grid.place(mat, it.shape, it.x, it.y, it.id);
                            }
                        }
                        // can place at target?
                        if(this.grid.canPlace(mat, item.shape, col, row)){
                            this.grid.place(mat, item.shape, col, row, item.id);
                            // persist positions in items and render
                            this.items.forEach(it=>{ if(it.id===id){ it.x = col; it.y = row; } });
                            const placed = this.items.filter(it=> typeof it.x === 'number' && typeof it.y === 'number').map(it=> Object.assign({}, it));
                            const free = this.grid.countFree(mat);
                            this.applyRender({ placed, free });
                            return;
                        }
                        // couldn't place: notify and re-render existing layout
                        this.showTemporaryWarning('Não coube nessa posição', 1200);
                        const placed = this.items.filter(it=> typeof it.x === 'number' && typeof it.y === 'number').map(it=> Object.assign({}, it));
                        const mat2 = this.grid.makeEmpty();
                        for(const p of placed) this.grid.place(mat2, p.shape, p.x, p.y, p.id);
                        const free = this.grid.countFree(mat2);
                        this.applyRender({ placed, free });
                    }

                    clear(){ this.items = []; this.nextId = 1; this.miniGridEl.innerHTML = ''; this.hideWarning(); this.enableAdd(); this.updateStatus(0, this.grid.w * this.grid.h); }

                    updateStatus(placedCount, freeCells){ if(this.countEl) this.countEl.textContent = `Itens: ${placedCount} — Espaços: ${freeCells}`; }

                    showWarning(text){ if(this.warnEl){ this.warnEl.textContent = text; this.warnEl.classList.remove('hidden'); } }
                    hideWarning(){ if(this.warnEl) this.warnEl.classList.add('hidden'); }
                    showTemporaryWarning(text, ms=1800){ if(this.warnEl){ const prev = this.warnEl.textContent; this.warnEl.textContent = text; this.warnEl.classList.remove('hidden'); setTimeout(()=>{ this.warnEl.classList.add('hidden'); this.warnEl.textContent = prev || 'Grid cheia — limpe para adicionar mais'; }, ms); } }

                    disableAdd(){ if(this.addBtn){ this.addBtn.disabled = true; this.addBtn.classList.add('opacity-50','cursor-not-allowed'); } }
                    enableAdd(){ if(this.addBtn){ this.addBtn.disabled = false; this.addBtn.classList.remove('opacity-50','cursor-not-allowed'); } }

                    // compact: call grid.compact and apply result if better
                    compact(){
                        const result = this.grid.compact(this.items);
                        if(result.placed.length > this.lastPlacedCount){
                            this.applyRender(result);
                            this.showTemporaryWarning(`Compactado — agora visíveis ${result.placed.length} itens`);
                            if(result.free > 0) this.enableAdd();
                        } else {
                            this.showTemporaryWarning('Compactação não aumentou itens visíveis', 1400);
                        }
                    }
                }

                // --- Initialize app ---
                const miniGridEl = document.getElementById('miniGrid');
                const addBtn = document.getElementById('addItemBtn');
                const compactBtn = document.getElementById('compactBtn');
                const clearBtn = document.getElementById('clearBtn');
                const miniCountEl = document.getElementById('miniCount');
                const miniWarningEl = document.getElementById('miniWarning');

                const app = new MiniBentoApp({ gridW: GRID_W, gridH: GRID_H, miniGridEl, addBtn, compactBtn, clearBtn, countEl: miniCountEl, warnEl: miniWarningEl });

                // expose add/clear for manual testing in console (not required)
                window.__miniBentoApp = app;

                // start empty
                app.updateStatus(0, GRID_W * GRID_H);
            })();
        </script>


</body>
</html>